---
title: "Ćwiczenie 07: *tidyverse* - cz. 3. Wprowadzenie do wykresów z *ggplot2*"
subtitle: "Materiały do kursu: Wprowadzenie do analizy danych w R (WBNZ-027, 2025/26)"

date: "12.06.2025"
author: "Remigiusz Pielech"

editor: visual
execute:
  warning: false
  message: false
format:
  pdf:
    toc: true
    number-sections: false
    # Wymaga włączenia zawijania linii dla kodu (listingów)
    code-block-breaklines: true 
    
    # Dodatkowe polecenia LaTeX (mniej zalecane, ale działa)
    include-in-header:
      text: |
        \usepackage{seqsplit}
        \usepackage{url}
        \PassOptionsToPackage{hyphens}{url}
---

# Wstęp

Na dzisiejszych zajęciach nie będziemy pracować z typowymi plikami skryptów R (pliki o rozszerzeniach `*.R`). Zaczniemy korzystać z dokumentów zbudowanych z instrukcji wyświetlanych w sformatowanych blokach tekstów, przeplatanych blokami kodu (*ang.* *code chunks*). Więcej o tym, jak tworzyć takie dokumenty, dowiesz się na kolejnych zajęciach.

## 1. Przygotuj środowisko pracy

### 1.1 Załaduj niezbędne pakiety

Poniższy kod załaduje niezbędne pakiety. Jeżeli w trakcie zajęć okaże się, że potrzebujesz nowe pakiety, wróć do tego miejsca. Pozwoli to utrzymać w Twoim dokumencie porządek, a następnym razem wszystkie niezbędne pakiety zostaną wczytane już na samym początku.

```{r}
library(tidyverse)
# w tym miejscu wczytuj kolejne potrzebne pakiety

```

### 1.2 Wczytaj dane do ćwiczeń

Wczytaj dane, które będziesz wykorzystywał na ćwiczeniach. Poniższy kod wczytuje zbiór `drapiezniki` bezpośrednio z repozytorium [GitHub](github.com/pielechr/Wprowadzenie_do_R) za pomocą funkcji `dplyr::read_delim()`.

```{r}
#| message: false
#| warning: false

drapiezniki <- read_delim("https://raw.githubusercontent.com/pielechr/Wprowadzenie_do_R/refs/heads/main/drapiezniki.csv")
drapiezniki

```

Wczytaj kolejne dane z [GitHub](github.com/pielechr/Wprowadzenie_do_R):

-   `drzewa.csv`

-   `species_list.csv`

-   `traits.csv`

```{r}


```

Wykorzystaj poniższą przestrzeń, aby wykorzystać kilka poznanych funkcji do zapoznania się z wczytanymi danymi:

```{r}


```

## 2. Łączenie danych

W trakcie przygotowywania danych do analiz lub wizualizacji, zachodzi często potrzeba połączenia danych z kilku różnych źródeł.

Najprostszym przykładem może być wykorzystanie słowników nazw. Wyobraź sobie, że masz dwie tabele:

-   główne dane (`species_list`) zawierające kolumnę z nazwami naukowymi (łacińskimi) drzew
-   słownik nazw drzew (`drzewa`), zawierający nazwy naukowe oraz polskie.

Korzystając ze słownika, chcesz przypisać do głównej tabeli nazwy polskie. Kolumną, która umożliwia połączenie obu tabel jest kolumna zawierająca nazwy naukowe.

Można to zrobić za pomocą kilku funkcji pakietu `dplyr`:

`left_join()`

`right_join()`

`inner_join()`

`full_join()`

Funkcje z rodziny `_join()` wykorzystują prostą filozofię - pierwsza z łączonych tabela to **tabela lewa**, druga tabela to **tabela prawa**. Różnice w działaniu pomiędzy poszczególnymi funkcjami dobrze ilustruje poniższa rycina:

![](images/clipboard-1931823406.png){width="400"}

### 2.1 `left_join()`

To funkcja, której będziesz używał najczęściej. Zasada działania `left_join()` polega na tym, że funkcja ta bierze wszystkie wiersze z lewej tabeli i stara się do niej dodać zmienne z prawej kolumny. Zasadę działania tej funkcji dobrze oddaje poniższa rycina:

![](images/clipboard-1284367488.png){width="300"}

```{r}
species_list %>%                               # lewa tabela
  left_join(drzewa,                            # wskazujemy prawą tabelę
            join_by(species == nazwa_naukowa)) # wskazujemy zmienne łączące tabele

```

Zauważ, że tabela wynikowa ma tyle samo wierszy, co lewa tabela wejściowa. Czy wszystkie drzewa mają przypisane polskie nazwy?

### 2.2 `right_join()`

![](images/clipboard-1915547526.png){width="300"}

Funkcja `right_join()` działa podobnie, jednak pozostawia wyłącznie wiersze pasujące do prawej tabeli:

```{r}



```

Teraz liczba wierszy jest większa. Wynikowa tabela zawiera te wiersze lewej tabeli, które pasowały to prawej tabeli. Dodatkowo zawiera wiersze z wartościami z prawej tabeli, mimo że nie było ich w lewej tabeli.

Dlaczego w wynikowej tabeli nie ma buka zwyczajnego (**Fagus sylvatica**)?

### 2.3 `inner_join()`

![](images/clipboard-1135534205.png){width="300"}

Ta funkcja zwraca tabelę z wierszami zawierającymi wartości występujące w obu tabelach:

```{r}



```

### 2.4 `full_join()`

![](images/clipboard-558437485.png){width="300"}

Funkcja `full_join()` zwraca wszystkie wiersze, bez względu czy znajdują one swoje odpowiedniki w drugiej łączonej tabeli, czy nie.

```{r}



```

### 2.5 funkcja `join_by()` vs. argument `by =`

Gdy łączone tabele mają różne nazwy kolumn przeznaczonych do ich łączenia, stosujemy funkcję `join_by()`

```{r}

```

Jeżeli natomiast łączone tabele mają tą samą nazwę kolumn przeznaczonych do ich łączenia, można wykorzystać argument `by =`:

```{r}

```

#### ZADANIE 7.1

Połącz tabelę `species_list` z cechami funkcjonalnymi `traits` za pomocą poznanych funkcji:

```{r}




```

#### ZADANIE 7.2

1.  Wczytaj z [GitHub](github.com/pielechr/Wprowadzenie_do_R) tabelę z nazwami wybranych ssaków `ssaki.csv`.
2.  Ze zbioru `drapiezniki` wybierz obserwacje z 5 ostatnich lat
3.  Przypisz polskie nazwy korzystajac z tabeli `ssaki`

Następnie wspólnie wykonamy następujące kroki: 4. Przenies kolumny z nazwami polską i naukową na początek 5. Wygeneruj podsumowanie zawierające liczbę obserwacji gatunków w poszczególnych latach. 6. Utwórz obiekt `wyniki` i przypisz do niego wygenerowane podsumowanie. Zbior ten przyda nam się w w kolejnej części ćwiczeń.

```{r}



```

## 3. Przekształcanie tabel za pomocą funkcji `pivot`

Przy analizach i wizualizacji danych często zachodzi potrzeba zmiany struktury danych z formatu szerokiego (**wide**) na długi (**long**) lub odwrotnie.

![](images/clipboard-2258235256.png)

Pakiet `tidyr` udostępnia funkcje `pivot_longer()` i `pivot_wider()` służące właśnie do tego celu. Przyjrzyjmy się teraz danym w naszym podsumowaniu `wyniki`.

```{r}
wyniki
```

### 3.1 `pivot_wider()`

`Wyniki` to klasyczny przyklad długiej tabeli. W każdym wierszu znajduje się jedna wartość liczbowa. Spróbujmy zamienić ją na tabelę szeroką.

```{r}
wyniki_wide <- wyniki %>% 
  pivot_wider(
    id_cols = species,             # kolumna, która identyfikuje wiersze
    names_from = year,             # chcemy, aby lata były nazwami kolumn
    values_from = liczba_obs       # liczba obserwacji to będą wartości
  )

```

### 3.2 `pivot_longer()`

Wykonajmy teraz operację odwrotną:

```{r}
wyniki_long <- wyniki_wide %>% 
  pivot_longer(
    cols = c("2021", "2022", "2023", "2024", "2025"),
    names_to = "rok",
    values_to = "liczba_obserwacji"
  )
wyniki_long
```

#### ZADANIE 7.3

1.  Do zbioru `species_list` dołącz dane dotyczace cech funkcjonalnych ze zbioru `traits`.
2.  Zamień tabelę na długą, zwijając zmienne **abundance**, **SLA** i **leaf_N**.

```{r}


```

## 4. Wprowadzenie do wykresów z pakietem `ggplot2`

### 4.1 Podstawowe elementy wykresu `ggplot`

`ggplot2` jest potężnym i bardzo elastycznym narzędziem pozwalającym na tworzenie znakomicie wyglądających wykresów. Główna filozofia tworzenia wykresów w `ggplot2` polega na tym, że na wykres składają się trzy główne elementy:

-   **dane**;

-   **estetyka (aestheics)**: tu określamy co znajdzie się na osi *x* i *y*, możemy również określić kolor, kształt i rozmiar elementów;

-   **geometria**: określa, jaki rodzaj wykresu chcemy wykonać, np. histogram, boxplot, wykres rozrzutu, wykres liniowy itp.

Sprawdźmy, czy pakiet ggplot2 jest załadowany:

```{r}

```

`ggplot2` jest częścią `tidyverse`, dlatego jest już wczytany. Jeśli nie używaliśmy wcześniej w danej sesji `tidyverse`, wystarczy wywołać go za pomocą:

```{r}

```

### 4.2 `ggplot()` - działanie i składnia

Wykonajmy pierwszy wykres:

```{r}



```

Powyżej używamy składni potokowej. Ten sam efekt uzyskamy zapisując kod w taki sposób:

```{r}


```

### 4.3 Modyfikowanie wykresu

Zmienimy teraz kolory wykresów. Odpowiadają za to argumenty `fill =` i `color =`:

```{r}



```

Za pomocą argumentów funkcji `geom_boxplot()` możemy modyfikować elementy wykresu pudełkowego

```{r}



```

Bardzo wygodną opcją jest zapisanie naszego wykresu jako obiektu, a następnie dodawanie do niego kolejnych funkcji zmieniających jego wygląd. Zapiszmy teraz wykreS jako obiekt `plot`:

```{r}



```

Teraz możemy dodawać kolejne funkcje modyfikujące wygląd naszego zapisanego wykresu.

`coord_flip()` zmienia wykres na poziomy

```{r}




```

`geom_jitter` dodaje do wykresu punkty oznaczające konkretne wartości danych

```{r}




```

Zmodyfiukujmy paletę kolorów, która jest wykorzystywana do tworzenia wykresu:

```{r}




```

Zmodyfikujemy teraz wyswietlane etykiety za pomocą finkcji `labs()`

```{r}




```

Możemy również zmieniać wygląd wykresów za pomocą tematów

```{r}




```

#### ZADANIE 7.4

1.  Wykonaj poziomy wykres pudełkowy prezentujący zróżnicowanie wysokości osobniów z rodzaju *Juncus*:

```{r}





```

---
title: "Cwiczenie_07"
author: "Remigiusz Pielech"
format: html
editor: visual
---

# Wstęp

Na dzisiejszych zajęciach nie będziemy pracować z typowymi plikami skryprów R (pliki o rozszerzeniach `*.R`). Zaczniemy korzystać z dokumentów zbudowanych z instrukcji wyświetlanych w sformatowanych blokach testów, przeplatanych blokami kodu (*ang.* *code chunks*). Więcej o tym, jak tworzyć takie dokumenty, dowiesz się na kolejnych zajęciach.

## 1. Przygotuj środowisko pracy

### 1.1 Załaduj niezbędne pakiety

Poniższy kod załaduje niezbędne pakiety. Jeżeli w trakcie zajęć okaże się, że potrzebujesz nowe pakiety, wróć do tego miejsca. Pozwoli to utrzymać w Twoim dokumencie porządek, a wszystkie niezbędne pakiety zostaną wczytane już na samym początku.

```{r}
library(tidyverse)
# w tym miejscu wczytuj kolejne potrzebne pakiety

```

### 1.2 Wczytaj dane do ćwiczeń

Wczytaj dane, które będziesz wykorzystywał na ćwiczeniach. Poniższy kod wczytuje zbiór `drapieżniki` bezpośrednio z repozytorium [GitHub](github.com/pielechr/Wprowadzenie_do_R) za pomocą funkcji `read_delim`.

```{r}

drapiezniki <- read_delim("https://raw.githubusercontent.com/pielechr/Wprowadzenie_do_R/refs/heads/main/drapiezniki.csv")

```

Wczytaj kolejne dane z [GitHub](github.com/pielechr/Wprowadzenie_do_R):

-   `drzewa.csv`

-   `species_list.csv`

-   `traits.csv`

```{r}


```

Wykorzystaj poniższą przestrzeń, aby wykorzystać kilka poznanych funkcji do zapoznania się z wczytanymi danymi:

```{r}


```

## 2. Łączenie danych

W trakcie przygotowywania danych do analiz lub wizualizacji, zachodzi często potrzeba połączenia danych z kilku różnych źródeł.

Najprostszym przykładem może być wykorzystanie słowników nazw. Wyobraź sobie, że masz dwie tabele:

-   główne dane (`species_list`) zawierające kolumnę z nazwami naukowymi (łacińskimi) drzew
-   słownik nazw drzew (`drzewa`), zawierający nazwy naukowe oraz polskie.

Korzystając ze słownika, chcesz przypisać do głównej tabeli nazwy polskie. Kolumną, która umożliwia połączenie obu tabel jest kolumna zawierająca nazwy naukowe

Można to zrobić za pomocą kilku funkcji pakietu `dplyr`:

`left_join()`

`right_join()`

`inner_join()`

`full_join()`

Funkcje z rodziny `_join()` wykorzystują prostą filozofię - pierwsza z łączonych tabela to **tabela lewa**, druga tabela to **tabela prawa.** Różnice w działaniu pomiędzy poszczególnymi funkcjami dobrze ilustruje poniższa rycina:

![](images/clipboard-1931823406.png)

### 2.1. `left_join()`

To funkcja, której będziesz używał najczęściej. Zasada działania `left_join()` polega na tym, że funkcja ta bierze wszystkie wiersze z lewej kolumny i stara się do niej dodać zmienne z prawej kolumny. Zasadę działania tej funkcji dobrze oddaje poniższa rycina:

[![](images/clipboard-1284367488.png){fig-alt="Źródło:" width="300"}](https://lindsaydbrin.github.io/CREATE_R_Workshop/Lesson_-_dplyr_join.html)

```{r}
species_list %>%                               # lewa tabela
  left_join(drzewa,                            # wskazujemy prawą tabelę
            join_by(species == nazwa_naukowa)) # wskazujemy zmienne łączące tabele


```

Zauważ, że tabela wynikowa ma tyle samo wierszy, co lewa tabela wejściowa. Czy wszystkie drzewa mają przypisane polskie nazwy?

#### ZADANIE 7.1

Spróbuj rozwinąć powyższy kod, aby utworzyć obiekt `samples` i przypisać do niego powyższą tabelę. Uporządkuj kolejność kolumn (plot_id/species/common_name/abundance) oraz posortuj wiersze (alfabetycznie wg. polskiej nazwy, a następnie wg. ilości). Do sortowania służy funkcja `arrange()`.

```{r}







```

### 2.2 `right_join()`

![](images/clipboard-1915547526.png){width="300"}

Funkcja `right_join()` działa podobnie, jednak pozostawia wyłącznie wiersze pasujące do prawej tabeli:

```{r}




```

Teraz liczba wierszy jest większa. Wynikowa tabela zawiera wszystkie wiersze lewej tabeli, które pasowały to prawej tabeli. Dodatkowo zawiera wiersze z wartościami z prawej tabeli, mimo że nie było ich w lewej tabeli.

Dlaczego w wynikowej tabeli nie ma buka zwyczajnego (**Fagus sylvatica**)?

### 2.3 `inner_join()`

![](images/clipboard-1135534205.png){width="300"}

Ta funkcja zwraca tabelę z wierszami zawierającymi wartości występujące w obu tabelach:

```{r}





```

### 2.4 `full_join()`

![](images/clipboard-558437485.png){width="300"}

Funkcja full_join() zwraca wszystkie wiersze, bez względu czy znajdują one swoje odpowiedniki w drugiej łączonej tabeli, czy nie.

```{r}





```

### 2.5 funkcja `join_by()` vs. argument `by =`

Gdy łączone tabele mają różne nazwy kolumn przeznaczonych do ich łączenmia, stosujemy funkcję `join_by()`

```{r}
species_list %>% 
  left_join(drzewa,
            join_by(species == nazwa_naukowa))
```

Jeżeli natomiast łączone tabele mają tą samą nazwę kolumn przeznaczonych do ich łączenia, można wykorzystać argument by:

```{r}
species_list %>% 
  right_join(traits,
            by = "species")
```

#### ZADANIE 7.2

Połącz tabelę `species_list` z cechami funkcjonalnymi za pomocą pozostałych funkcji:

```{r}




```

#### ZADANIE 7.3

1.  Wczytaj z [GitHub](github.com/pielechr/Wprowadzenie_do_R) tabelę z nazwami wybranych ssaków `ssaki.csv`.
2.  Ze zbioru `drapiezniki` wybierz obserwacje z 5 ostatnich lat
3.  Przypisz polskie nazwy korzystajac z tabeli `ssaki`
4.  Przenies kolumny z nazwami polską i naukową na początek
5.  Wygeneruj podsumowanie zawierające liczbę obserwacji w poszczególnych latach.
6.  Utwórz obiekt `wyniki` i przypisz do niego wygenerowane podsumowanie. Zbior ten przyda nam się w w kolejnej części ćwiczeń.

```{r}









```

## 3. Przekształcanie tabel za pomocą funkcji `pivot`

Przy analizach i wizualizacji danych często zachodzi potrzeba zmiany struktury danych z formatu szerokiego (**wide**) na długi (**long**) lub odwrotnie.

[![](images/clipboard-2258235256.png)](https://www.rforecology.com/post/reshaping-data-in-r/)

Pakiet `tidyr` udostępnia funkcje `pivot_longer()` i `pivot_wider()` służące właśnie do tego celu. Przyjrzyjmy się teraz danym w naszym podsumowaniu `wyniki`.

```{r}
wyniki
```

To jest klasyczny przyklad długiej tabeli. Spróbujmy zamienić ją na tabelę szeroką.

```{r}
wyniki_wide <- wyniki %>% 
  pivot_wider(
    id_cols = polish_name,         # kolumna, która identyfikuje wiersze
    names_from = year,             # chcemy, aby lata były nazwami kolumn
    values_from = liczba_obs       # liczba obserwacji to będą wartości
  )

```

Wykonajmy teraz operację odwrotną:

```{r}
wyniki_long <- wyniki_wide %>% 
  pivot_longer(
    cols = c(`2021`, `2022`, `2023`, `2024`, `2025`),
    names_to = "rok",
    values_to = "liczba_obserwacji"
  )
wyniki_long
```

#### ZADANIE 7.4

1.  Do zbioru `species_list` dołącz dane dotyczace cech funkcjonalnych ze zbioru `traits`.
2.  Zamień tabelę na długą, zwijając zmienne **abundance**, **SLA** i **leaf_N**.

```{r}






```

## 4. Wykresy z pakietem `ggplot2`

`ggplot2` jest potężnym i bardzo elastycznym narzędziem pozwalającym na tworzenie znakomicie wyglądających wykresów. Główna filozofia tworzenia wykresów w `ggplot2` polega na tym, że na wykres składają się trzy główne elementy: -

-   **dane**;

-   **estetyka (aestheics)**: tu określamy co znajdzie się na osi *x* i *y*, możemy również określić kolor, kształt i rozmiar elementów;

-   **geometria**: określa, jaki rodzaj wykresu chcemy wykonać, np. histogram, boxplot, wykres rozrzutu, wykres liniowy itp.

Sprawdźmy, czy pakiet ggplot2 jest załadowany:

```{r}
sessionInfo()
```

`ggplot2` jest częścią `tidyverse`, dlatego jest już wczytany. Jeśli nie używaliśmy wcześniej w danej sesji `tidyverse`, wystarczy wywołać go za pomocą:

```{r}
library(ggplot2)
```

Wykonajmy pierwszy wykres:

```{r}
iris %>%                                         # dane
  ggplot(aes(x = Species, y = Petal.Length)) +   # estetyka
  geom_boxplot()                                 # geometria


```

Powyżej używamy składni potokowej. Ten sam efekt uzyskamy zapisując kod w taki sposób:

```{r}

               
  ggplot(iris,                                   # dane
         aes(x = Species, y = Petal.Length)) +   # estetyka
  geom_boxplot()                                 # geometria

```

Zmienimy teraz kolory wykresów. Odpowiadają za to argumenty fill i color:

```{r}



```

Za pomocą argumentów funkcji `geom_boxplot` możemy modyfikować elementy wykresu pudełkowego

```{r}




```

Bardzo wygodną opcją jest zapisanie naszego wykresu jako obiektu, a następnie dodawanie do niego kolejnych funkcji zmieniających jego wygląd. Zapiszmy teraz wykrej jako obiekt `plot`:

```{r}




```

Teraz możemy dodawać kolejne funkcje modyfikujące wygląd naszego zapisanego wykresu.

`coord_flip()` zmienia wykres na poziomy

```{r}




```

`geom_jitter` dodaje do wykresu punkty oznaczające konkretne wartości danych:

```{r}




```

Zmodyfiukujmy paletę kolorów, która jest wykorzystywana do tworzenia wykresu:

```{r}



```

Zmodyfikujemy teraz wyswietlane etykiety za pomocą finkcji `labs()`

```{r}



```

Możemy również zmieniać wygląd wykresów za pomocą tematów

```{r}




```




#### ZADANIE 7.5

1.  Wykonaj poziomy wykres pudełkowy prezentujący zróżnicowanie wysokości osobniów z rodzaju Juncus:

```{r}





```


